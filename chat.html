<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chatbot con Gemini - Modelos</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
    />
    <style>
      :root {
        --primary-color: #4a6fa5;
        --secondary-color: #166088;
        --accent-color: #4fc3f7;
        --user-color: #d3f8d3;
        --bot-color: #f0f0f0;
        --error-color: #f44336;
        --success-color: #4caf50;
        --warning-color: #ff9800;
        --text-color: #333;
        --light-text: #777;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        margin: 0;
        padding: 20px;
        color: var(--text-color);
      }

      .chat-container {
        width: 800px;
        max-width: 100%;
        background-color: white;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        height: 700px;
        position: relative;
        transition: all 0.3s ease;
      }

      .chat-header {
        background: linear-gradient(
          to right,
          var(--primary-color),
          var(--secondary-color)
        );
        color: white;
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .chat-title {
        font-size: 1.5rem;
        font-weight: 600;
      }

      .chat-actions {
        display: flex;
        gap: 10px;
      }

      .action-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }

      .action-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }

      .chat-box {
        flex-grow: 1;
        padding: 20px;
        overflow-y: auto;
        background-color: #f9f9f9;
        display: flex;
        flex-direction: column;
        scroll-behavior: smooth;
      }

      .message {
        max-width: 70%;
        padding: 12px 16px;
        margin-bottom: 15px;
        border-radius: 18px;
        position: relative;
        word-wrap: break-word;
        line-height: 1.4;
        animation-duration: 0.3s;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        opacity: 0;
        transform: translateY(10px);
        animation: fadeInUp 0.3s forwards;
      }

      @keyframes fadeInUp {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .user {
        align-self: flex-end;
        background-color: var(--user-color);
        color: #1a531b;
        border-bottom-right-radius: 5px;
        animation-delay: 0.1s;
      }

      .bot {
        align-self: flex-start;
        background-color: var(--bot-color);
        border-bottom-left-radius: 5px;
        animation-delay: 0.2s;
      }

      /* Estilo específico para mensajes en streaming */
      .bot.streaming {
        background-color: #e8e8e8; /* Slightly lighter background */
        opacity: 0.8; /* Semi-transparent to indicate it's in progress */
      }

      .system {
        align-self: center;
        background-color: var(--accent-color);
        color: white;
        font-size: 0.9rem;
        padding: 8px 12px;
        border-radius: 12px;
        margin: 5px 0;
        animation-delay: 0s;
      }

      .message-time {
        font-size: 0.7rem;
        color: var(--light-text);
        margin-top: 5px;
        text-align: right;
        display: none; /* Oculto por defecto, se muestra al final del streaming */
      }

      .message-options {
        position: absolute;
        top: 5px;
        right: 5px;
        opacity: 0;
        transition: opacity 0.2s;
        display: none; /* Oculto por defecto, se muestra al final del streaming */
      }

      .message:hover .message-options {
        opacity: 1;
      }
      /* Asegurarnos que las opciones solo aparezcan al final */
      .message:not(.streaming-finished):hover .message-options {
        opacity: 0;
      }
      .message.streaming-finished:hover .message-options,
      .message.streaming-finished .message-time {
        display: block; /* O flex si es necesario */
        opacity: 1;
      }
      .message.streaming-finished .message-time {
        display: block; /* Asegura que el tiempo se muestre */
      }

      .option-btn {
        background: rgba(0, 0, 0, 0.1);
        border: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        color: #555;
      }

      .option-btn:hover {
        background: rgba(0, 0, 0, 0.2);
      }

      .typing-indicator {
        display: flex;
        align-self: flex-start;
        padding: 10px 15px;
        background-color: var(--bot-color);
        border-radius: 18px;
        margin-bottom: 15px;
        border-bottom-left-radius: 5px;
      }

      .typing-dot {
        width: 8px;
        height: 8px;
        background-color: #666;
        border-radius: 50%;
        margin: 0 2px;
        animation: typingAnimation 1.4s infinite ease-in-out;
      }

      .typing-dot:nth-child(1) {
        animation-delay: 0s;
      }

      .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typingAnimation {
        0%,
        60%,
        100% {
          transform: translateY(0);
        }
        30% {
          transform: translateY(-5px);
        }
      }

      .input-container {
        display: flex;
        padding: 15px;
        background-color: white;
        border-top: 1px solid #eee;
        position: relative;
      }

      .user-input {
        flex-grow: 1;
        padding: 12px 15px;
        border: 1px solid #ddd;
        border-radius: 25px;
        outline: none;
        font-size: 1rem;
        transition: all 0.3s;
        resize: none; /* Para evitar que el usuario redimensione si usamos textarea */
        min-height: 45px; /* Altura mínima igual al botón */
        max-height: 150px; /* Limitar expansión */
        overflow-y: auto; /* Scroll si excede max-height */
      }

      .user-input:focus {
        border-color: var(--accent-color);
        box-shadow: 0 0 0 3px rgba(79, 195, 247, 0.2);
      }

      .send-btn {
        background-color: var(--primary-color);
        color: white;
        border: none;
        width: 45px;
        height: 45px;
        border-radius: 50%;
        margin-left: 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        align-self: flex-end; /* Alinear con la parte inferior del textarea si crece */
      }

      .send-btn:hover {
        background-color: var(--secondary-color);
        transform: scale(1.05);
      }

      .send-btn i {
        font-size: 1.2rem;
      }

      .send-btn:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        transform: none;
      }
      .user-input:disabled {
        background-color: #f8f8f8;
        cursor: not-allowed;
      }

      .status-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 15px;
        border-radius: 20px;
        font-size: 0.9rem;
        display: none; /* Cambiado a flex al mostrar */
        align-items: center;
        gap: 5px;
        z-index: 1000;
      }

      .model-selector {
        position: absolute;
        top: 10px;
        left: 20px;
        background-color: white;
        border-radius: 20px;
        padding: 5px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        display: flex;
        z-index: 10;
      }

      .model-btn {
        background: none;
        border: none;
        padding: 5px 10px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 0.8rem;
        transition: all 0.2s;
        white-space: nowrap;
      }

      .model-btn.active {
        background-color: var(--primary-color);
        color: white;
      }

      .model-btn:hover:not(.active) {
        background-color: #f0f0f0;
      }

      .model-info {
        position: absolute;
        top: 40px;
        left: 20px;
        background-color: white;
        border-radius: 10px;
        padding: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        font-size: 0.8rem;
        max-width: 300px;
        display: none;
        z-index: 10;
      }

      .settings-panel {
        position: absolute;
        top: 60px;
        right: 20px;
        background-color: white;
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        z-index: 100;
        display: none;
        width: 250px;
      }

      .settings-panel h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1rem;
        color: var(--primary-color);
      }

      .settings-option {
        margin-bottom: 10px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .settings-option label {
        font-size: 0.9rem;
      }

      .settings-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        cursor: pointer;
        color: var(--light-text);
      }

      .message-content {
        white-space: pre-wrap; /* Importante para respetar saltos de línea y espacios */
      }

      .hidden {
        display: none !important;
      }

      /* Nuevos estilos para los botones de cuenta */
      .account-actions {
        display: flex;
        flex-direction: column;
        margin-top: 20px;
        border-top: 1px solid #eee;
        padding-top: 15px;
      }

      .account-btn {
        width: 100%;
        padding: 10px;
        border: none;
        border-radius: 8px;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .account-btn:hover {
        opacity: 0.9;
        transform: translateY(-2px);
      }

      .account-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .dark-mode .account-btn {
        background-color: #4a5568; /* Darker background */
        color: #f7fafc; /* Light text for contrast */
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .chat-container {
          height: 100vh;
          border-radius: 0;
        }

        .message {
          max-width: 85%;
        }

        .model-selector {
          top: 5px;
          left: 5px;
        }

        .model-info {
          top: 35px;
          left: 5px;
          max-width: 200px;
        }
      }

      /* Dark mode styles */
      .dark-mode {
        background: linear-gradient(135deg, #2c3e50 0%, #1a1a2e 100%);
        color: #f0f0f0;
      }

      .dark-mode .chat-container {
        background-color: #2d3748;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      .dark-mode .chat-header {
        background: linear-gradient(to right, #1e3a8a, #1e40af);
      }

      .dark-mode .chat-box {
        background-color: #1a202c;
      }

      .dark-mode .user {
        background-color: #2c5282;
        color: #ebf8ff;
      }

      .dark-mode .bot {
        background-color: #4a5568;
        color: #f7fafc;
      }

      /* --- Dark Mode Typing Indicator --- */
      .dark-mode .typing-indicator {
        background-color: #4a5568;
      }
      .dark-mode .typing-dot {
        background-color: #a0aec0;
      }

      .dark-mode .input-container {
        background-color: #2d3748;
        border-top: 1px solid #4a5568;
      }

      .dark-mode .user-input {
        background-color: #4a5568;
        border-color: #4a5568;
        color: #f7fafc;
      }

      .dark-mode .user-input:focus {
        border-color: var(--accent-color);
        box-shadow: 0 0 0 3px rgba(79, 195, 247, 0.3);
      }

      .dark-mode .user-input:disabled {
        background-color: #3a4150;
      }

      .dark-mode .send-btn {
        background-color: #1e40af;
      }

      .dark-mode .send-btn:hover {
        background-color: #1e3a8a;
      }

      .dark-mode .send-btn:disabled {
        background-color: #5a667a;
      }

      .dark-mode .option-btn {
        color: #ccc;
        background: rgba(255, 255, 255, 0.1);
      }

      .dark-mode .option-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .dark-mode .model-selector,
      .dark-mode .model-info,
      .dark-mode .settings-panel {
        background-color: #2d3748;
        color: #f7fafc;
      }

      .dark-mode .model-btn {
        color: #f7fafc;
      }

      .dark-mode .model-btn:hover:not(.active) {
        background-color: #4a5568;
      }

      .dark-mode .model-btn.active {
        background-color: #1e40af;
      }

      .dark-mode .settings-panel h3 {
        color: var(--accent-color);
      }
      .dark-mode .settings-close {
        color: #a0aec0;
      }
      .dark-mode .message-time {
        color: #a0aec0;
      }

      .dark-mode .account-btn {
        /* Ajustar colores si es necesario, o dejarlos como están si los colores base funcionan */
        /* Ejemplo: Podrías querer que el color del texto sea más claro si el fondo es oscuro */
        color: white;
      }
      .dark-mode .account-actions {
        border-top-color: #4a5568;
      }
    </style>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
  </head>
  <body>
    <div class="chat-container">
      <div class="chat-header">
        <div class="chat-title">Chatbot con Gemini</div>
        <div class="chat-actions">
          <button
            class="action-btn"
            id="dark-mode-btn"
            title="Modo oscuro"
            aria-label="Cambiar tema"
          >
            <i class="fas fa-moon"></i>
          </button>
          <button
            class="action-btn"
            id="settings-btn"
            title="Configuración"
            aria-label="Abrir configuración"
          >
            <i class="fas fa-cog"></i>
          </button>
          <button
            class="action-btn"
            id="clear-chat-btn"
            title="Limpiar chat"
            aria-label="Limpiar chat"
          >
            <i class="fas fa-trash"></i>
          </button>
        </div>
      </div>

      <div class="model-selector">
        <button
          class="model-btn active"
          data-model="gemini-1.5-pro-latest"
          aria-pressed="true"
        >
          Gemini 1.5 Pro
        </button>
        <button
          class="model-btn"
          data-model="gemini-1.0-pro"
          aria-pressed="false"
        >
          Gemini 1.0 Pro
        </button>
        <button
          class="model-btn"
          data-model="gemini-1.5-flash"
          aria-pressed="false"
        >
          Gemini 1.5 Flash
        </button>
      </div>

      <div class="model-info" id="model-info" role="tooltip" aria-hidden="true">
        Modelo actual: Gemini 1.5 Pro (última versión)
      </div>

      <div class="settings-panel" id="settings-panel" aria-hidden="true">
        <button
          class="settings-close"
          id="settings-close"
          aria-label="Cerrar configuración"
        >
          <i class="fas fa-times"></i>
        </button>
        <h3>Configuración del Chatbot</h3>
        <div class="settings-option">
          <label for="temperature">Temperatura:</label>
          <input
            type="range"
            id="temperature"
            min="0"
            max="1"
            step="0.1"
            value="0.9"
            aria-describedby="temperature-value"
          />
          <span id="temperature-value" aria-live="polite">0.9</span>
        </div>
        <div class="settings-option">
          <label for="max-tokens">Máx. tokens:</label>
          <input
            type="number"
            id="max-tokens"
            min="100"
            max="8192"
            value="2048"
          />
        </div>
        <div class="settings-option">
          <label for="enable-history">Guardar historial:</label>
          <input type="checkbox" id="enable-history" checked />
        </div>

        <div class="account-actions">
          <button
            id="logout-btn"
            class="account-btn"
            style="background-color: #f44336; color: white"
          >
            <i class="fas fa-sign-out-alt"></i> Cerrar sesión
          </button>
          <button
            id="delete-account-btn"
            class="account-btn"
            style="background-color: #ff9800; color: white; margin-top: 10px"
          >
            <i class="fas fa-trash-alt"></i> Borrar cuenta
          </button>
        </div>
      </div>

      <div
        id="chat-box"
        class="chat-box"
        aria-live="polite"
        aria-atomic="false"
      >
        <div class="message system animate__animated animate__fadeIn">
          <div class="message-content">
            ¡Hola! Soy un chatbot potenciado por Google Gemini. ¿En qué puedo
            ayudarte hoy?
          </div>
          <!-- Añadimos tiempo a mensajes iniciales si se desea -->
          <div class="message-time" style="display: block"></div>
        </div>
      </div>

      <div class="input-container">
        <!-- Cambiado a textarea para multilínea y auto-ajuste -->
        <textarea
          id="user-input"
          class="user-input"
          placeholder="Escribe tu mensaje... (Shift+Enter para nueva línea)"
          rows="1"
        ></textarea>
        <button id="send-btn" class="send-btn" aria-label="Enviar mensaje">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>

      <div
        class="status-indicator"
        id="status-indicator"
        role="status"
        aria-live="assertive"
      >
        <i class="fas fa-circle-notch fa-spin"></i>
        <span id="status-text">Procesando...</span>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "@google/generative-ai": "https://esm.run/@google/generative-ai"
        }
      }
    </script>
    <script type="module">
      import { GoogleGenerativeAI } from "@google/generative-ai";

      // --- ¡ADVERTENCIA DE SEGURIDAD! ---
      // ¡NO EXPONGAS TU API KEY AQUÍ EN PRODUCCIÓN!
      // Esta clave debería estar en un backend seguro.
      // Cualquiera puede verla en las herramientas de desarrollador del navegador.
      const API_KEY = "AIzaSyBWxRM9DJB-qzjpl741ArFJsQYR9lhE1xk";
      // ---------------------------------
      const genAI = new GoogleGenerativeAI(API_KEY);

      // Estado de la aplicación
      const appState = {
        darkMode: localStorage.getItem("darkMode") === "true",
        isTyping: false, // Ahora indica si el bot está "pensando" antes del stream
        isStreaming: false, // Indica si está activamente mostrando una respuesta
        currentModel: "gemini-1.5-pro-latest",
        settings: {
          temperature: 0.9,
          maxTokens: 2048,
          enableHistory: true,
        },
        chatHistory: [], // Opcional: para guardar historial si se implementa persistencia
      };

      // Modelos disponibles
      const models = {
        "gemini-1.5-pro-latest": {
          name: "Gemini 1.5 Pro",
          description:
            "Modelo más avanzado con contexto extendido (última versión)",
        },
        "gemini-1.0-pro": {
          name: "Gemini 1.0 Pro",
          description: "Modelo estándar para la mayoría de casos de uso",
        },
        "gemini-1.5-flash": {
          name: "Gemini 1.5 Flash",
          description: "Versión más rápida y económica para respuestas rápidas",
        },
      };

      // Elementos del DOM
      const DOM = {
        body: document.body,
        chatContainer: document.querySelector(".chat-container"),
        chatBox: document.getElementById("chat-box"),
        userInput: document.getElementById("user-input"), // Ahora es textarea
        sendBtn: document.getElementById("send-btn"),
        darkModeBtn: document.getElementById("dark-mode-btn"),
        clearChatBtn: document.getElementById("clear-chat-btn"),
        settingsBtn: document.getElementById("settings-btn"),
        settingsClose: document.getElementById("settings-close"),
        settingsPanel: document.getElementById("settings-panel"),
        statusIndicator: document.getElementById("status-indicator"),
        statusText: document.getElementById("status-text"),
        modelInfo: document.getElementById("model-info"),
        modelButtons: document.querySelectorAll(".model-btn"),
        temperatureSlider: document.getElementById("temperature"),
        temperatureValue: document.getElementById("temperature-value"),
        maxTokens: document.getElementById("max-tokens"),
        enableHistory: document.getElementById("enable-history"),
        logoutBtn: document.getElementById("logout-btn"),
        deleteAccountBtn: document.getElementById("delete-account-btn"),
      };

      // Verificar autenticación al cargar
      function checkAuth() {
        if (!localStorage.getItem("currentUser")) {
          window.location.href = "index.html";
        } else {
          // Opcional: Personalizar saludo
          const currentUser = JSON.parse(localStorage.getItem("currentUser"));
          const firstSystemMessage = DOM.chatBox.querySelector(
            ".message.system .message-content"
          );
          if (firstSystemMessage && currentUser?.username) {
            firstSystemMessage.textContent = `¡Hola, ${currentUser.username}! Soy un chatbot potenciado por Google Gemini. ¿En qué puedo ayudarte hoy?`;
          }
          // Asignar hora a mensajes iniciales si se desea
          const initialMessages = DOM.chatBox.querySelectorAll(
            ".message:not(.user):not(.bot)"
          );
          initialMessages.forEach((msg) => {
            const timeElement = msg.querySelector(".message-time");
            if (timeElement) {
              const now = new Date();
              timeElement.textContent = now.toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit",
              });
              timeElement.style.display = "block"; // Mostrar tiempo inicial
            }
          });
        }
      }

      // Inicialización de la aplicación
      function initApp() {
        checkAuth();
        loadSettings();
        setupEventListeners();
        updateUI();
        updateModelInfo();
        // Opcional: Cargar historial de chat si se implementa persistencia
        // loadChatHistory();
      }

      // Cargar configuración desde localStorage
      function loadSettings() {
        const savedSettings = localStorage.getItem("geminiChatSettings");
        appState.darkMode = localStorage.getItem("darkMode") === "true"; // Asegurar carga modo oscuro

        if (savedSettings) {
          try {
            const settings = JSON.parse(savedSettings);
            appState.currentModel =
              settings.currentModel || "gemini-1.5-pro-latest";
            // Solo sobrescribir settings si existen en el objeto guardado
            if (settings.settings) {
              appState.settings = {
                ...appState.settings,
                ...settings.settings,
              };
            }

            // Actualizar controles de UI
            DOM.temperatureSlider.value = appState.settings.temperature;
            DOM.temperatureValue.textContent = appState.settings.temperature;
            DOM.maxTokens.value = appState.settings.maxTokens;
            DOM.enableHistory.checked = appState.settings.enableHistory;

            // Activar el botón del modelo correcto
            DOM.modelButtons.forEach((btn) => {
              const isActive = btn.dataset.model === appState.currentModel;
              btn.classList.toggle("active", isActive);
              btn.setAttribute("aria-pressed", isActive);
            });
          } catch (e) {
            console.error("Error loading settings:", e);
            // Si hay error, resetear a default para evitar problemas
            localStorage.removeItem("geminiChatSettings");
          }
        }
      }

      // Guardar configuración en localStorage
      function saveSettings() {
        const settings = {
          currentModel: appState.currentModel,
          settings: appState.settings,
        };
        localStorage.setItem("geminiChatSettings", JSON.stringify(settings));
        // Guardar modo oscuro por separado
        localStorage.setItem("darkMode", appState.darkMode);
      }

      // Configurar event listeners
      function setupEventListeners() {
        // Envío de mensajes (adaptado para textarea)
        DOM.sendBtn.addEventListener("click", sendMessage);
        DOM.userInput.addEventListener("keypress", (e) => {
          // Enviar con Enter (si no se presiona Shift)
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault(); // Evitar nueva línea por defecto
            sendMessage();
          }
        });
        // Auto-ajuste de altura del textarea
        DOM.userInput.addEventListener("input", autoResizeTextarea);

        // Botones de acción
        DOM.darkModeBtn.addEventListener("click", toggleDarkMode);
        DOM.clearChatBtn.addEventListener("click", clearChat);
        DOM.settingsBtn.addEventListener("click", toggleSettingsPanel);
        DOM.settingsClose.addEventListener("click", toggleSettingsPanel);

        // Selector de modelos
        DOM.modelButtons.forEach((btn) => {
          btn.addEventListener("click", () => changeModel(btn.dataset.model));
        });

        // Configuración
        DOM.temperatureSlider.addEventListener("input", (e) => {
          appState.settings.temperature = parseFloat(e.target.value);
          DOM.temperatureValue.textContent = e.target.value;
          saveSettings();
        });
        DOM.temperatureSlider.addEventListener("change", saveSettings); // Guardar al soltar

        DOM.maxTokens.addEventListener("change", (e) => {
          appState.settings.maxTokens = parseInt(e.target.value) || 2048; // Valor por defecto si es inválido
          DOM.maxTokens.value = appState.settings.maxTokens; // Asegurar que el input muestre el valor validado
          saveSettings();
        });

        DOM.enableHistory.addEventListener("change", (e) => {
          appState.settings.enableHistory = e.target.checked;
          saveSettings();
          // Aquí iría lógica para borrar/guardar historial si se implementa persistencia
        });

        // Cerrar sesión
        DOM.logoutBtn.addEventListener("click", logoutUser);

        // Borrar cuenta
        DOM.deleteAccountBtn.addEventListener("click", deleteAccount);
      }

      // Función para auto-ajustar textarea
      function autoResizeTextarea() {
        DOM.userInput.style.height = "auto"; // Resetear altura
        DOM.userInput.style.height = DOM.userInput.scrollHeight + "px"; // Ajustar a contenido
      }

      // Función para cerrar sesión
      function logoutUser() {
        if (appState.isStreaming) return; // No permitir durante streaming
        if (confirm("¿Estás seguro de que quieres cerrar sesión?")) {
          DOM.logoutBtn.disabled = true; // Deshabilitar botón
          localStorage.removeItem("currentUser");
          localStorage.removeItem("geminiChatSettings"); // Opcional: borrar config al salir
          localStorage.removeItem("darkMode");
          window.location.href = "index.html";
        }
      }

      // Función para borrar cuenta
      function deleteAccount() {
        if (appState.isStreaming) return; // No permitir durante streaming
        DOM.deleteAccountBtn.disabled = true; // Deshabilitar inmediatamente
        const confirmation = prompt(
          "Esta acción borrará tu cuenta permanentemente y no se puede deshacer. Escribe tu nombre de usuario para confirmar:"
        );
        const currentUser = JSON.parse(localStorage.getItem("currentUser"));

        if (confirmation === currentUser?.username) {
          if (currentUser) {
            // Obtener todos los usuarios
            const users = JSON.parse(localStorage.getItem("chatUsers") || "[]");

            // Filtrar el usuario actual
            const updatedUsers = users.filter(
              (user) => user.username !== currentUser.username
            );

            // Guardar los usuarios actualizados
            localStorage.setItem("chatUsers", JSON.stringify(updatedUsers));

            // Eliminar el usuario actual y sus settings
            localStorage.removeItem("currentUser");
            localStorage.removeItem("geminiChatSettings");
            localStorage.removeItem("darkMode");
            // Opcional: Eliminar historial de chat si existe
            // localStorage.removeItem(`chatHistory_${currentUser.username}`);

            // Mostrar mensaje y redirigir
            showStatusIndicator(
              "Cuenta eliminada correctamente. Redirigiendo...",
              "success"
            );
            setTimeout(() => {
              window.location.href = "index.html";
            }, 2500);
          } else {
            showStatusIndicator(
              "Error: No se encontró usuario actual.",
              "error"
            );
            DOM.deleteAccountBtn.disabled = false; // Rehabilitar si falla
          }
        } else if (confirmation !== null) {
          // Si escribió algo pero no coincide
          alert(
            "Nombre de usuario incorrecto. La cuenta no ha sido eliminada."
          );
          DOM.deleteAccountBtn.disabled = false; // Rehabilitar
        } else {
          // Si canceló el prompt
          DOM.deleteAccountBtn.disabled = false; // Rehabilitar
        }
      }

      // Actualizar la interfaz según el estado
      function updateUI() {
        // Modo oscuro/claro
        if (appState.darkMode) {
          DOM.body.classList.add("dark-mode");
          DOM.darkModeBtn.innerHTML = '<i class="fas fa-sun"></i>';
          DOM.darkModeBtn.title = "Modo claro";
          DOM.darkModeBtn.setAttribute("aria-label", "Cambiar a modo claro");
        } else {
          DOM.body.classList.remove("dark-mode");
          DOM.darkModeBtn.innerHTML = '<i class="fas fa-moon"></i>';
          DOM.darkModeBtn.title = "Modo oscuro";
          DOM.darkModeBtn.setAttribute("aria-label", "Cambiar a modo oscuro");
        }
      }

      // Actualizar información del modelo
      function updateModelInfo() {
        const model = models[appState.currentModel];
        DOM.modelInfo.textContent = `${model.name}: ${model.description}`;
      }

      // Mostrar/ocultar panel de configuración
      function toggleSettingsPanel() {
        const isHidden =
          DOM.settingsPanel.style.display === "none" ||
          DOM.settingsPanel.style.display === "";
        DOM.settingsPanel.style.display = isHidden ? "block" : "none";
        DOM.settingsPanel.setAttribute("aria-hidden", !isHidden);
        if (isHidden) {
          DOM.settingsPanel.querySelector("input, button").focus(); // Foco al primer elemento
        }
      }

      // Cambiar modelo de Gemini
      function changeModel(modelId) {
        if (appState.isStreaming) return; // No cambiar modelo durante streaming

        appState.currentModel = modelId;
        saveSettings();

        // Actualizar botones de modelo
        DOM.modelButtons.forEach((btn) => {
          const isActive = btn.dataset.model === modelId;
          btn.classList.toggle("active", isActive);
          btn.setAttribute("aria-pressed", isActive);
        });

        updateModelInfo();
        addSystemMessage(`Modelo cambiado a ${models[modelId].name}`);
      }

      // Alternar modo oscuro
      function toggleDarkMode() {
        appState.darkMode = !appState.darkMode;
        updateUI();
        saveSettings(); // Guardar preferencia de modo oscuro
      }

      // Limpiar el chat
      function clearChat() {
        if (appState.isStreaming) return; // No limpiar durante streaming
        if (confirm("¿Estás seguro de que quieres limpiar el chat?")) {
          DOM.chatBox.innerHTML = ""; // Limpia el contenido
          addSystemMessage(
            "¡Hola! Soy un chatbot potenciado por Google Gemini. ¿En qué puedo ayudarte hoy?"
          );
          // Opcional: Limpiar historial si se implementa persistencia
          // appState.chatHistory = [];
          // if(appState.settings.enableHistory) {
          //    localStorage.removeItem(`chatHistory_${JSON.parse(localStorage.getItem('currentUser')).username}`);
          // }
        }
      }

      // Manejar el envío de mensajes
      function sendMessage() {
        if (appState.isStreaming) return; // Prevenir envío durante streaming

        const message = DOM.userInput.value.trim();
        if (message === "") return;

        addMessage(message, "user");
        DOM.userInput.value = "";
        autoResizeTextarea(); // Resetear altura del textarea
        DOM.userInput.focus(); // Mantener foco en input

        // Mostrar indicador de "escribiendo" (ahora es más un "pensando")
        showTypingIndicator(); // O renombrar a showThinkingIndicator()

        // Deshabilitar input y botón mientras procesa
        DOM.userInput.disabled = true;
        DOM.sendBtn.disabled = true;

        // Procesar con Gemini (ahora con streaming)
        processWithGemini(message);
      }

      // *** FUNCIÓN MODIFICADA PARA STREAMING ***
      async function processWithGemini(message) {
        appState.isStreaming = true; // Marcar inicio de streaming
        showStatusIndicator("Generando respuesta..."); // Cambiar texto si se desea

        // Crear el elemento del mensaje del bot ANTES de iniciar el stream
        const botMessageElement = createMessageElement("bot", true); // true indica que está en streaming
        const botContentElement =
          botMessageElement.querySelector(".message-content");
        DOM.chatBox.appendChild(botMessageElement);
        scrollToBottom();

        // Ocultar el indicador de "typing" una vez que empezamos a mostrar la respuesta
        hideTypingIndicator();
        let fullResponseText = ""; // Acumulador para el texto completo

        try {
          const model = genAI.getGenerativeModel({
            model: appState.currentModel,
            generationConfig: {
              temperature: appState.settings.temperature,
              maxOutputTokens: appState.settings.maxTokens,
            },
          });

          const result = await model.generateContentStream(message);

          // Iterar sobre los chunks del stream
          for await (const chunk of result.stream) {
            const chunkText = chunk.text();
            fullResponseText += chunkText;
            botContentElement.textContent = fullResponseText; // Actualizar el contenido en tiempo real
            scrollToBottom(); // Mantener visible el final
          }

          // --- Stream Terminado ---
          addMessageOptions(botMessageElement, fullResponseText); // Añadir hora y botón de copia
          botMessageElement.classList.remove("streaming"); // Quitar clase de streaming
          botMessageElement.classList.add("streaming-finished"); // Marcar como finalizado

          // Opcional: Guardar en historial si está habilitado
          // if (appState.settings.enableHistory) {
          //    saveToHistory({ sender: 'bot', content: fullResponseText, timestamp: Date.now() });
          // }
        } catch (error) {
          console.error("Error al generar contenido:", error);
          botContentElement.textContent =
            "Lo siento, hubo un error al procesar tu mensaje. Por favor, inténtalo de nuevo.";
          botMessageElement.classList.add("error"); // Opcional: Clase para estilizar errores
          addMessageOptions(botMessageElement, botContentElement.textContent); // Permitir copiar error
          botMessageElement.classList.remove("streaming");
          botMessageElement.classList.add("streaming-finished"); // Marcar como finalizado (aunque sea error)
          showStatusIndicator("Error al generar respuesta", "error", 3000);
        } finally {
          // --- Siempre se ejecuta al final (éxito o error) ---
          appState.isStreaming = false; // Marcar fin de streaming
          hideStatusIndicator();
          // Rehabilitar input y botón
          DOM.userInput.disabled = false;
          DOM.sendBtn.disabled = false;
          DOM.userInput.focus(); // Devolver foco al input
        }
      }

      // --- Funciones Auxiliares para Mensajes ---

      // Crea la estructura base de un elemento de mensaje
      function createMessageElement(sender, isStreaming = false) {
        const messageElement = document.createElement("div");
        // Añadir clase 'streaming' si es el caso
        const streamingClass = isStreaming ? "streaming" : "streaming-finished";
        messageElement.className = `message ${sender} animate__animated animate__fadeIn ${streamingClass}`;

        const contentElement = document.createElement("div");
        contentElement.className = "message-content";
        // Dejar vacío inicialmente si es streaming, o añadir contenido si no
        messageElement.appendChild(contentElement);

        // Placeholder para tiempo y opciones (se añaden después en streaming)
        const timeElement = document.createElement("div");
        timeElement.className = "message-time";
        messageElement.appendChild(timeElement);

        const optionsElement = document.createElement("div");
        optionsElement.className = "message-options";
        messageElement.appendChild(optionsElement);

        return messageElement;
      }

      // Añade contenido, hora y opciones a un mensaje (usado para user y system, y al final del stream para bot)
      function finalizeMessage(messageElement, content, sender) {
        const contentElement = messageElement.querySelector(".message-content");
        contentElement.textContent = content; // Asegura que el contenido final esté

        // Añadir hora del mensaje
        const now = new Date();
        const timeElement = messageElement.querySelector(".message-time");
        timeElement.textContent = now.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });
        timeElement.style.display = "block"; // Mostrar hora

        // Añadir botón de copiar (excepto para mensajes del sistema)
        if (sender !== "system") {
          addMessageOptions(messageElement, content);
        }

        // Marcar como finalizado (si no lo estaba ya)
        messageElement.classList.remove("streaming");
        messageElement.classList.add("streaming-finished");
      }

      // Añade opciones (copiar) a un mensaje - llamada después del stream o para mensajes de usuario/sistema
      function addMessageOptions(messageElement, contentToCopy) {
        const optionsElement = messageElement.querySelector(".message-options");
        if (!optionsElement) return; // Salir si no existe

        // Limpiar opciones previas si las hubiera (relevante si se re-genera)
        optionsElement.innerHTML = "";

        // Botón de Copiar
        const copyBtn = document.createElement("button");
        copyBtn.className = "option-btn";
        copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
        copyBtn.title = "Copiar mensaje";
        copyBtn.setAttribute("aria-label", "Copiar mensaje");
        copyBtn.addEventListener("click", (e) => {
          e.stopPropagation(); // Evitar que el hover del mensaje interfiera
          navigator.clipboard
            .writeText(contentToCopy)
            .then(() => {
              // Feedback visual sutil
              copyBtn.innerHTML = '<i class="fas fa-check"></i>';
              setTimeout(() => {
                copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
              }, 1500);
            })
            .catch((err) => {
              console.error("Error al copiar:", err);
              showStatusIndicator("Error al copiar", "error", 2000);
            });
        });

        optionsElement.appendChild(copyBtn);
        optionsElement.style.display = "flex"; // Mostrar contenedor de opciones
      }

      // Añadir mensaje COMPLETO al chat (Usuario o Sistema)
      function addMessage(content, sender) {
        const messageElement = createMessageElement(sender, false); // false = no streaming
        DOM.chatBox.appendChild(messageElement);
        finalizeMessage(messageElement, content, sender); // Añadir contenido, hora, opciones

        // Opcional: Guardar en historial si está habilitado
        // if (appState.settings.enableHistory && sender !== 'system') {
        //    saveToHistory({ sender, content, timestamp: Date.now() });
        // }

        scrollToBottom();
        return messageElement; // Devolver el elemento por si se necesita
      }

      // Añadir mensaje del sistema
      function addSystemMessage(content) {
        return addMessage(content, "system");
      }

      // Mostrar indicador de "escribiendo/pensando"
      function showTypingIndicator() {
        if (appState.isTyping) return; // Ya está visible

        appState.isTyping = true;
        const existingIndicator = document.getElementById("typing-indicator");
        if (existingIndicator) return; // Ya existe, no añadir otro

        const typingElement = document.createElement("div");
        typingElement.className = "typing-indicator";
        typingElement.id = "typing-indicator"; // Asignar ID
        typingElement.setAttribute("aria-label", "El bot está escribiendo");
        typingElement.setAttribute("role", "status");

        for (let i = 0; i < 3; i++) {
          const dot = document.createElement("div");
          dot.className = "typing-dot";
          typingElement.appendChild(dot);
        }

        DOM.chatBox.appendChild(typingElement);
        scrollToBottom();
      }

      // Ocultar indicador de "escribiendo/pensando"
      function hideTypingIndicator() {
        appState.isTyping = false;
        const typingElement = document.getElementById("typing-indicator");
        if (typingElement) {
          typingElement.remove();
        }
      }

      // Mostrar indicador de estado general
      function showStatusIndicator(text, type = "info", duration = null) {
        let iconClass;
        switch (type) {
          case "success":
            iconClass = "fas fa-check-circle";
            DOM.statusIndicator.style.backgroundColor = "var(--success-color)";
            break;
          case "error":
            iconClass = "fas fa-exclamation-circle";
            DOM.statusIndicator.style.backgroundColor = "var(--error-color)";
            break;
          case "warning":
            iconClass = "fas fa-exclamation-triangle";
            DOM.statusIndicator.style.backgroundColor = "var(--warning-color)";
            break;
          default: // info o procesando
            iconClass = "fas fa-circle-notch fa-spin";
            DOM.statusIndicator.style.backgroundColor = "rgba(0, 0, 0, 0.7)"; // Default background
        }

        DOM.statusIndicator.querySelector("i").className = iconClass; // Actualizar icono
        DOM.statusText.textContent = text; // Actualizar texto
        DOM.statusIndicator.style.display = "flex";

        // Ocultar automáticamente después de una duración si se especifica
        if (duration) {
          setTimeout(hideStatusIndicator, duration);
        }
      }

      // Ocultar indicador de estado general
      function hideStatusIndicator() {
        DOM.statusIndicator.style.display = "none";
      }

      // Desplazar chat al fondo
      function scrollToBottom() {
        DOM.chatBox.scrollTop = DOM.chatBox.scrollHeight;
      }

      // Mostrar información del modelo al pasar el ratón
      DOM.modelButtons.forEach((btn) => {
        btn.addEventListener("mouseenter", () => {
          const model = models[btn.dataset.model];
          DOM.modelInfo.textContent = `${model.name}: ${model.description}`;
          DOM.modelInfo.style.display = "block";
          DOM.modelInfo.setAttribute("aria-hidden", "false");
        });

        btn.addEventListener("mouseleave", () => {
          DOM.modelInfo.style.display = "none";
          DOM.modelInfo.setAttribute("aria-hidden", "true");
          // No es necesario llamar a updateModelInfo aquí, ya que el texto se restaura implícitamente la próxima vez que se cambie el modelo o se recargue.
        });
      });

      // Inicializar la aplicación cuando el DOM esté listo
      document.addEventListener("DOMContentLoaded", initApp);
    </script>
  </body>
</html>
